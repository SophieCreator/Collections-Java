# Collections-Java

## Задание 1
Реализуй метод, который поменяет ключи и значения в HashMap местами. На вход в метод поступает HashMap<Interger, String>, надо вернуть HashMap<String, Integer>. Выведи результат.

### Решение
Так как параметры коллекции статичны (HashMap<Interger, String> -> HashMap<String, Integer> невозможно), функция будет возвращать HashMap<String, Integer>. Мы инициализируем новую HashMap и просто переписываем в неё данные из исходной, меняя позиции ключа и значения. Операции извлечения и сохранения константны, их мы проделываем n раз, где n - размер HashMap. Итоговая сложность - O(n).

## Задание 2
Реализуй метод, в котором создаются ArrayList, LinkedList и заполняются 1 000 000 случайными элементами одного и того же типа. После из ArrayList и LinkedList 1000 раз выбираем элемент по случайному индексу. Замерь время для ArrayList и LinkedList. Сравни результаты и предположи, почему они могут отличаться.
### Решение
Для измерения времени работы каждого участка кода использовалась функция фиксации времени System.currentTimeMillis(). Для выбора случайного элемента использовался метод random.

В случае вставки элемента по индексу ArrayList был быстрее примерно в 4 раза (хотя обе вставки занимали малое количество времени). Вероятнее всего разница в скорости объясняется тем, что LinkedList - связный список, который хранит указатель на предыдущий и следующий элемент, а, значит, при вставке нового элемента необходимо создавать также и указатели (которых попросту нет в ArrayList).

В случае поиска элемента по индексу ArrayList существенно быстрее, так как он основан на массиве: доступ к элементу осуществляется за константное время. В случае же связного списка придётся пройтись по порядку по элементам, чтобы найти подходящий (в худшем случае сложность O(n)).

## Задание 3
Реализуй метод, который на вход примет ArrayList строк и удаляет из него все дубликаты, не используя метод contains(). Можно использовать другие коллекции, которые были изучены на уроке.
### Решение
Я привела две реализации. Первая очень простая, она основана на записи элементов ArrayList в LinkedHashSet (выбрана эта коллекция, так как она устойчивая и в ней отсуствуют повторы) за O(n), последующее очищение исходного массива за O(n) и заполнение его элементами LinkedHashSet за O(m). Получаем решение за O(n+n+m), где n - исходный массив, m - целевой, m < n, то есть получим решение в несколько строк за O(n) - линейное время. Это решение показалось мне читерским, поэтому я сделала вторую реализацию. 

Второй вариант основан на составлении словаря уже встретившихся слов. Мы совершаем один проход по исходному массиву, занося в HashMap новые слова и удаляя те, которые уже были в словаре. Операция удаления линейна, значит, решение квадратично, O(n^2).
